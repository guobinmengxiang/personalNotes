synchronized 锁住都是对象，而非其中的一段代码、一个函数、一个方法。所以上述代码中，
那个线程先执行 synchronized 关键字的方法，哪个线程就持有该方法所属对象的锁的 Lock，
注意这里持有的是该方法所属对象的 Lock，以对象为基准，
其他线程若想调用该对象或该对象内部任何加锁函数的情况下，只能进行等待。

但若多个线程访问多个对象，则 JVM 虚拟机则会创建多个锁，每个锁都由一个线程进行获取，
所以互不影响的情况下，两段线程是以异步的方式进行执行的。

若一个函数中含有多个需要加锁的函数时，需要给每个需要加锁的函数都加上锁，否则还是非安全的

多线程访问同一对象时，并且这个对象上有锁，当一个线程执行异常时，后面等待的线程会直接调用这个对象及内部的函数，
因为当一个线程执行异常时，会自动释放锁
synchronized 无法被继承
synchronized 锁的重入：
所谓重入即是，当前线程 A 获得了一个对象的 synchronized 锁后，在没有释放的情况下，线程 A 再次请求该对象时，
依旧可以重新进行请求。
当线程 A 获得一个对象的 synchronzied 锁后，在没有释放的情况下，线程 B 是无法再次请求该对象的。
以上情况即是 synchronized 锁的重入，这也说明在一个 synchronized 方法 / 代码块内部调用本类其它 
synchronized 方法 / 代码块的情况下，是永远可以得到这个锁的。

静态同步与实例同步的区别 static synchronized
其本质的区别即，synchronized public static void something() 
与实例同步synchronized public void something() 使用的并不是同一把锁，
关键点在于 satatic synchronized 静态同步是将锁放置在了 Class 类上。

死锁
死锁是程序设计中的 Bug，在设计程序的时候就要避免双方互相持有对方锁的情况，需要说明的是，并非只有嵌套 synchronized 
才会出现死锁，只要互相等待对方释放锁的情况下，即有可能触发死锁，死锁是程序设计中的致命问题。
而且实际生产中并不好去排查，所以一定在编写代码的时候就防患于未然，检查是否有互相持有对方锁的情况产生。

线程的等待与唤醒
wait() 的作用是使当前执行代码的线程进行等待，wait() 方法是 Object 类的方法，该方法用来将当前线程放置“预执行队列之中”，并且在 wait() 所在的代码行处停止执行，知道接到通知或被中断为止。
在调用 wait() 方法之前，线程必须获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait() 方法。
在调用 wait() 方法时，如果没有持有适当的锁，则抛出 IllegalMonitorStateException 异常。
在执行 wait() 方法返回前，线程与其他线程竞争重新获得锁。
在执行 wait() 方法之后，当前线程释放锁

notify() 的作用是唤醒、通知那些可能等待该对象锁的其它线程，如果有多个线程等待，则有线程规划器随机挑选出一个 wait() 的线程，对其发送 notify() 指令，并使它获得该对象的对象锁，notify()方法需要在同步方法，或同步模块中进行调用。

在调用 notify() 方法之前，线程必须获得该对象的对象级别锁。
在调用 notify() 方法时，如果没有适当的锁则会抛出 IllegalMonitorStateException 异常。
在调用 notify() 方法之后，当前线程不会马上释放对象锁，呈现 wait 状态 的线程也不能马上获取该对象锁，要等到执行 notify 方法的线程将程序执行完，退出 synchronized 代码块之后，当前线程才会释放锁，而呈现 wait 状态所在的线程才可以获取该对象锁。
在获得对象锁的 wait 状态 的线程执行完 synchronized 代码块之后，它会释放掉该对象锁。此时如果没有对象再次使用 notify() 方法，则即使对象已经空闲，其它 wait 状态 的线程由于没有 notify() 的通知，所以其它 wait 状态 的线程依旧保持着 wait 状态 （没有修理员通知客户的话，客户也不会取车，也不知道需要去取车）。

notifyAll() 函数
唤醒全部线程

在很多情况下，主线程创建并启动了子线程，如果子线程中要进行大量的耗时运算，
主线程往往将早于子线程结束之前结束，这时如果主线程想等待子线程执行完成之后结束的话，
例如子线程处理一个数据，主线程想取得这个数据中的值
，就要用到 join() 方法了。方法 join() 的作用是等待线程销毁。

join() 重载的函数
join() 函数之外，还有 join(long) 函数和 join(long,int) 函数
join(long) 函数
最多等待{long}毫秒，使此线程死亡。如果当前代码超时则意味着永远等待。
此实现使用 This.wait 循环调用，条件是 This.isAlive 。当线程终止代码时，调用 this.notifyAll 方法。建议应用程序不要同时使用 wait 、 notify 或 notifyAll 。
join(long,int) 函数
最多等待 (long) 毫秒加上{int}纳秒，使此线程死亡。
此实现使用 This.wait 循环调用，条件是 This.isAlive 。当线程终止代码时，调用 this.notifyAll 方法。建议应用程序不要同时使用 wait 、 notify 或 notifyAll 。
值得注意的是 join() 、 join(long) 、 join(long,int) 都有唤醒、释放锁的特点，所以不要与 wait() 、 notify() 、 notifyAll()同时使用， join() 函数内部就是由 wait() 函数进行实现的，

线程副本
